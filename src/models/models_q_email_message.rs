/* 
 * SendPost API
 *
 * SendPost API to send transactional emails reliably
 *
 * OpenAPI spec version: 1.0.0
 * Contact: hello@sendx.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ModelsQEmailMessage {
  #[serde(rename = "accountID")]
  account_id: Option<i64>,
  #[serde(rename = "ampBody")]
  amp_body: Option<String>,
  #[serde(rename = "customFields")]
  custom_fields: Option<Value>,
  #[serde(rename = "emailType")]
  email_type: Option<String>,
  #[serde(rename = "from")]
  from: Option<::models::ModelsFrom>,
  #[serde(rename = "groups")]
  groups: Option<Value>,
  #[serde(rename = "headers")]
  headers: Option<Value>,
  #[serde(rename = "htmlBody")]
  html_body: Option<String>,
  #[serde(rename = "ipID")]
  ip_id: Option<i64>,
  #[serde(rename = "ipPool")]
  ip_pool: Option<String>,
  #[serde(rename = "localIP")]
  local_ip: Option<String>,
  #[serde(rename = "messageID")]
  message_id: Option<String>,
  #[serde(rename = "preText")]
  pre_text: Option<String>,
  #[serde(rename = "publicIP")]
  public_ip: Option<String>,
  #[serde(rename = "replyTo")]
  reply_to: Option<::models::ModelsReplyTo>,
  #[serde(rename = "subAccountID")]
  sub_account_id: Option<i64>,
  #[serde(rename = "subject")]
  subject: Option<String>,
  #[serde(rename = "submittedAt")]
  submitted_at: Option<i64>,
  #[serde(rename = "textBody")]
  text_body: Option<String>,
  #[serde(rename = "to")]
  to: Option<::models::ModelsTo>,
  #[serde(rename = "trackClicks")]
  track_clicks: Option<bool>,
  #[serde(rename = "trackOpens")]
  track_opens: Option<bool>
}

impl ModelsQEmailMessage {
  pub fn new() -> ModelsQEmailMessage {
    ModelsQEmailMessage {
      account_id: None,
      amp_body: None,
      custom_fields: None,
      email_type: None,
      from: None,
      groups: None,
      headers: None,
      html_body: None,
      ip_id: None,
      ip_pool: None,
      local_ip: None,
      message_id: None,
      pre_text: None,
      public_ip: None,
      reply_to: None,
      sub_account_id: None,
      subject: None,
      submitted_at: None,
      text_body: None,
      to: None,
      track_clicks: None,
      track_opens: None
    }
  }

  pub fn set_account_id(&mut self, account_id: i64) {
    self.account_id = Some(account_id);
  }

  pub fn with_account_id(mut self, account_id: i64) -> ModelsQEmailMessage {
    self.account_id = Some(account_id);
    self
  }

  pub fn account_id(&self) -> Option<&i64> {
    self.account_id.as_ref()
  }

  pub fn reset_account_id(&mut self) {
    self.account_id = None;
  }

  pub fn set_amp_body(&mut self, amp_body: String) {
    self.amp_body = Some(amp_body);
  }

  pub fn with_amp_body(mut self, amp_body: String) -> ModelsQEmailMessage {
    self.amp_body = Some(amp_body);
    self
  }

  pub fn amp_body(&self) -> Option<&String> {
    self.amp_body.as_ref()
  }

  pub fn reset_amp_body(&mut self) {
    self.amp_body = None;
  }

  pub fn set_custom_fields(&mut self, custom_fields: Value) {
    self.custom_fields = Some(custom_fields);
  }

  pub fn with_custom_fields(mut self, custom_fields: Value) -> ModelsQEmailMessage {
    self.custom_fields = Some(custom_fields);
    self
  }

  pub fn custom_fields(&self) -> Option<&Value> {
    self.custom_fields.as_ref()
  }

  pub fn reset_custom_fields(&mut self) {
    self.custom_fields = None;
  }

  pub fn set_email_type(&mut self, email_type: String) {
    self.email_type = Some(email_type);
  }

  pub fn with_email_type(mut self, email_type: String) -> ModelsQEmailMessage {
    self.email_type = Some(email_type);
    self
  }

  pub fn email_type(&self) -> Option<&String> {
    self.email_type.as_ref()
  }

  pub fn reset_email_type(&mut self) {
    self.email_type = None;
  }

  pub fn set_from(&mut self, from: ::models::ModelsFrom) {
    self.from = Some(from);
  }

  pub fn with_from(mut self, from: ::models::ModelsFrom) -> ModelsQEmailMessage {
    self.from = Some(from);
    self
  }

  pub fn from(&self) -> Option<&::models::ModelsFrom> {
    self.from.as_ref()
  }

  pub fn reset_from(&mut self) {
    self.from = None;
  }

  pub fn set_groups(&mut self, groups: Value) {
    self.groups = Some(groups);
  }

  pub fn with_groups(mut self, groups: Value) -> ModelsQEmailMessage {
    self.groups = Some(groups);
    self
  }

  pub fn groups(&self) -> Option<&Value> {
    self.groups.as_ref()
  }

  pub fn reset_groups(&mut self) {
    self.groups = None;
  }

  pub fn set_headers(&mut self, headers: Value) {
    self.headers = Some(headers);
  }

  pub fn with_headers(mut self, headers: Value) -> ModelsQEmailMessage {
    self.headers = Some(headers);
    self
  }

  pub fn headers(&self) -> Option<&Value> {
    self.headers.as_ref()
  }

  pub fn reset_headers(&mut self) {
    self.headers = None;
  }

  pub fn set_html_body(&mut self, html_body: String) {
    self.html_body = Some(html_body);
  }

  pub fn with_html_body(mut self, html_body: String) -> ModelsQEmailMessage {
    self.html_body = Some(html_body);
    self
  }

  pub fn html_body(&self) -> Option<&String> {
    self.html_body.as_ref()
  }

  pub fn reset_html_body(&mut self) {
    self.html_body = None;
  }

  pub fn set_ip_id(&mut self, ip_id: i64) {
    self.ip_id = Some(ip_id);
  }

  pub fn with_ip_id(mut self, ip_id: i64) -> ModelsQEmailMessage {
    self.ip_id = Some(ip_id);
    self
  }

  pub fn ip_id(&self) -> Option<&i64> {
    self.ip_id.as_ref()
  }

  pub fn reset_ip_id(&mut self) {
    self.ip_id = None;
  }

  pub fn set_ip_pool(&mut self, ip_pool: String) {
    self.ip_pool = Some(ip_pool);
  }

  pub fn with_ip_pool(mut self, ip_pool: String) -> ModelsQEmailMessage {
    self.ip_pool = Some(ip_pool);
    self
  }

  pub fn ip_pool(&self) -> Option<&String> {
    self.ip_pool.as_ref()
  }

  pub fn reset_ip_pool(&mut self) {
    self.ip_pool = None;
  }

  pub fn set_local_ip(&mut self, local_ip: String) {
    self.local_ip = Some(local_ip);
  }

  pub fn with_local_ip(mut self, local_ip: String) -> ModelsQEmailMessage {
    self.local_ip = Some(local_ip);
    self
  }

  pub fn local_ip(&self) -> Option<&String> {
    self.local_ip.as_ref()
  }

  pub fn reset_local_ip(&mut self) {
    self.local_ip = None;
  }

  pub fn set_message_id(&mut self, message_id: String) {
    self.message_id = Some(message_id);
  }

  pub fn with_message_id(mut self, message_id: String) -> ModelsQEmailMessage {
    self.message_id = Some(message_id);
    self
  }

  pub fn message_id(&self) -> Option<&String> {
    self.message_id.as_ref()
  }

  pub fn reset_message_id(&mut self) {
    self.message_id = None;
  }

  pub fn set_pre_text(&mut self, pre_text: String) {
    self.pre_text = Some(pre_text);
  }

  pub fn with_pre_text(mut self, pre_text: String) -> ModelsQEmailMessage {
    self.pre_text = Some(pre_text);
    self
  }

  pub fn pre_text(&self) -> Option<&String> {
    self.pre_text.as_ref()
  }

  pub fn reset_pre_text(&mut self) {
    self.pre_text = None;
  }

  pub fn set_public_ip(&mut self, public_ip: String) {
    self.public_ip = Some(public_ip);
  }

  pub fn with_public_ip(mut self, public_ip: String) -> ModelsQEmailMessage {
    self.public_ip = Some(public_ip);
    self
  }

  pub fn public_ip(&self) -> Option<&String> {
    self.public_ip.as_ref()
  }

  pub fn reset_public_ip(&mut self) {
    self.public_ip = None;
  }

  pub fn set_reply_to(&mut self, reply_to: ::models::ModelsReplyTo) {
    self.reply_to = Some(reply_to);
  }

  pub fn with_reply_to(mut self, reply_to: ::models::ModelsReplyTo) -> ModelsQEmailMessage {
    self.reply_to = Some(reply_to);
    self
  }

  pub fn reply_to(&self) -> Option<&::models::ModelsReplyTo> {
    self.reply_to.as_ref()
  }

  pub fn reset_reply_to(&mut self) {
    self.reply_to = None;
  }

  pub fn set_sub_account_id(&mut self, sub_account_id: i64) {
    self.sub_account_id = Some(sub_account_id);
  }

  pub fn with_sub_account_id(mut self, sub_account_id: i64) -> ModelsQEmailMessage {
    self.sub_account_id = Some(sub_account_id);
    self
  }

  pub fn sub_account_id(&self) -> Option<&i64> {
    self.sub_account_id.as_ref()
  }

  pub fn reset_sub_account_id(&mut self) {
    self.sub_account_id = None;
  }

  pub fn set_subject(&mut self, subject: String) {
    self.subject = Some(subject);
  }

  pub fn with_subject(mut self, subject: String) -> ModelsQEmailMessage {
    self.subject = Some(subject);
    self
  }

  pub fn subject(&self) -> Option<&String> {
    self.subject.as_ref()
  }

  pub fn reset_subject(&mut self) {
    self.subject = None;
  }

  pub fn set_submitted_at(&mut self, submitted_at: i64) {
    self.submitted_at = Some(submitted_at);
  }

  pub fn with_submitted_at(mut self, submitted_at: i64) -> ModelsQEmailMessage {
    self.submitted_at = Some(submitted_at);
    self
  }

  pub fn submitted_at(&self) -> Option<&i64> {
    self.submitted_at.as_ref()
  }

  pub fn reset_submitted_at(&mut self) {
    self.submitted_at = None;
  }

  pub fn set_text_body(&mut self, text_body: String) {
    self.text_body = Some(text_body);
  }

  pub fn with_text_body(mut self, text_body: String) -> ModelsQEmailMessage {
    self.text_body = Some(text_body);
    self
  }

  pub fn text_body(&self) -> Option<&String> {
    self.text_body.as_ref()
  }

  pub fn reset_text_body(&mut self) {
    self.text_body = None;
  }

  pub fn set_to(&mut self, to: ::models::ModelsTo) {
    self.to = Some(to);
  }

  pub fn with_to(mut self, to: ::models::ModelsTo) -> ModelsQEmailMessage {
    self.to = Some(to);
    self
  }

  pub fn to(&self) -> Option<&::models::ModelsTo> {
    self.to.as_ref()
  }

  pub fn reset_to(&mut self) {
    self.to = None;
  }

  pub fn set_track_clicks(&mut self, track_clicks: bool) {
    self.track_clicks = Some(track_clicks);
  }

  pub fn with_track_clicks(mut self, track_clicks: bool) -> ModelsQEmailMessage {
    self.track_clicks = Some(track_clicks);
    self
  }

  pub fn track_clicks(&self) -> Option<&bool> {
    self.track_clicks.as_ref()
  }

  pub fn reset_track_clicks(&mut self) {
    self.track_clicks = None;
  }

  pub fn set_track_opens(&mut self, track_opens: bool) {
    self.track_opens = Some(track_opens);
  }

  pub fn with_track_opens(mut self, track_opens: bool) -> ModelsQEmailMessage {
    self.track_opens = Some(track_opens);
    self
  }

  pub fn track_opens(&self) -> Option<&bool> {
    self.track_opens.as_ref()
  }

  pub fn reset_track_opens(&mut self) {
    self.track_opens = None;
  }

}



