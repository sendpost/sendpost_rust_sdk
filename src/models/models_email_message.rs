/* 
 * SendPost API
 *
 * SendPost API to send transactional emails reliably
 *
 * OpenAPI spec version: 1.0.0
 * Contact: hello@sendx.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ModelsEmailMessage {
  #[serde(rename = "ampBody")]
  amp_body: Option<String>,
  #[serde(rename = "from")]
  from: Option<::models::ModelsFrom>,
  #[serde(rename = "groups")]
  groups: Option<Value>,
  #[serde(rename = "headers")]
  headers: Option<Value>,
  #[serde(rename = "htmlBody")]
  html_body: Option<String>,
  #[serde(rename = "ippool")]
  ippool: Option<String>,
  #[serde(rename = "preText")]
  pre_text: Option<String>,
  #[serde(rename = "replyTo")]
  reply_to: Option<::models::ModelsReplyTo>,
  #[serde(rename = "subject")]
  subject: Option<String>,
  #[serde(rename = "template")]
  template: Option<String>,
  #[serde(rename = "textBody")]
  text_body: Option<String>,
  #[serde(rename = "to")]
  to: Option<Vec<::models::ModelsTo>>,
  #[serde(rename = "trackClicks")]
  track_clicks: Option<bool>,
  #[serde(rename = "trackOpens")]
  track_opens: Option<bool>
}

impl ModelsEmailMessage {
  pub fn new() -> ModelsEmailMessage {
    ModelsEmailMessage {
      amp_body: None,
      from: None,
      groups: None,
      headers: None,
      html_body: None,
      ippool: None,
      pre_text: None,
      reply_to: None,
      subject: None,
      template: None,
      text_body: None,
      to: None,
      track_clicks: None,
      track_opens: None
    }
  }

  pub fn set_amp_body(&mut self, amp_body: String) {
    self.amp_body = Some(amp_body);
  }

  pub fn with_amp_body(mut self, amp_body: String) -> ModelsEmailMessage {
    self.amp_body = Some(amp_body);
    self
  }

  pub fn amp_body(&self) -> Option<&String> {
    self.amp_body.as_ref()
  }

  pub fn reset_amp_body(&mut self) {
    self.amp_body = None;
  }

  pub fn set_from(&mut self, from: ::models::ModelsFrom) {
    self.from = Some(from);
  }

  pub fn with_from(mut self, from: ::models::ModelsFrom) -> ModelsEmailMessage {
    self.from = Some(from);
    self
  }

  pub fn from(&self) -> Option<&::models::ModelsFrom> {
    self.from.as_ref()
  }

  pub fn reset_from(&mut self) {
    self.from = None;
  }

  pub fn set_groups(&mut self, groups: Value) {
    self.groups = Some(groups);
  }

  pub fn with_groups(mut self, groups: Value) -> ModelsEmailMessage {
    self.groups = Some(groups);
    self
  }

  pub fn groups(&self) -> Option<&Value> {
    self.groups.as_ref()
  }

  pub fn reset_groups(&mut self) {
    self.groups = None;
  }

  pub fn set_headers(&mut self, headers: Value) {
    self.headers = Some(headers);
  }

  pub fn with_headers(mut self, headers: Value) -> ModelsEmailMessage {
    self.headers = Some(headers);
    self
  }

  pub fn headers(&self) -> Option<&Value> {
    self.headers.as_ref()
  }

  pub fn reset_headers(&mut self) {
    self.headers = None;
  }

  pub fn set_html_body(&mut self, html_body: String) {
    self.html_body = Some(html_body);
  }

  pub fn with_html_body(mut self, html_body: String) -> ModelsEmailMessage {
    self.html_body = Some(html_body);
    self
  }

  pub fn html_body(&self) -> Option<&String> {
    self.html_body.as_ref()
  }

  pub fn reset_html_body(&mut self) {
    self.html_body = None;
  }

  pub fn set_ippool(&mut self, ippool: String) {
    self.ippool = Some(ippool);
  }

  pub fn with_ippool(mut self, ippool: String) -> ModelsEmailMessage {
    self.ippool = Some(ippool);
    self
  }

  pub fn ippool(&self) -> Option<&String> {
    self.ippool.as_ref()
  }

  pub fn reset_ippool(&mut self) {
    self.ippool = None;
  }

  pub fn set_pre_text(&mut self, pre_text: String) {
    self.pre_text = Some(pre_text);
  }

  pub fn with_pre_text(mut self, pre_text: String) -> ModelsEmailMessage {
    self.pre_text = Some(pre_text);
    self
  }

  pub fn pre_text(&self) -> Option<&String> {
    self.pre_text.as_ref()
  }

  pub fn reset_pre_text(&mut self) {
    self.pre_text = None;
  }

  pub fn set_reply_to(&mut self, reply_to: ::models::ModelsReplyTo) {
    self.reply_to = Some(reply_to);
  }

  pub fn with_reply_to(mut self, reply_to: ::models::ModelsReplyTo) -> ModelsEmailMessage {
    self.reply_to = Some(reply_to);
    self
  }

  pub fn reply_to(&self) -> Option<&::models::ModelsReplyTo> {
    self.reply_to.as_ref()
  }

  pub fn reset_reply_to(&mut self) {
    self.reply_to = None;
  }

  pub fn set_subject(&mut self, subject: String) {
    self.subject = Some(subject);
  }

  pub fn with_subject(mut self, subject: String) -> ModelsEmailMessage {
    self.subject = Some(subject);
    self
  }

  pub fn subject(&self) -> Option<&String> {
    self.subject.as_ref()
  }

  pub fn reset_subject(&mut self) {
    self.subject = None;
  }

  pub fn set_template(&mut self, template: String) {
    self.template = Some(template);
  }

  pub fn with_template(mut self, template: String) -> ModelsEmailMessage {
    self.template = Some(template);
    self
  }

  pub fn template(&self) -> Option<&String> {
    self.template.as_ref()
  }

  pub fn reset_template(&mut self) {
    self.template = None;
  }

  pub fn set_text_body(&mut self, text_body: String) {
    self.text_body = Some(text_body);
  }

  pub fn with_text_body(mut self, text_body: String) -> ModelsEmailMessage {
    self.text_body = Some(text_body);
    self
  }

  pub fn text_body(&self) -> Option<&String> {
    self.text_body.as_ref()
  }

  pub fn reset_text_body(&mut self) {
    self.text_body = None;
  }

  pub fn set_to(&mut self, to: Vec<::models::ModelsTo>) {
    self.to = Some(to);
  }

  pub fn with_to(mut self, to: Vec<::models::ModelsTo>) -> ModelsEmailMessage {
    self.to = Some(to);
    self
  }

  pub fn to(&self) -> Option<&Vec<::models::ModelsTo>> {
    self.to.as_ref()
  }

  pub fn reset_to(&mut self) {
    self.to = None;
  }

  pub fn set_track_clicks(&mut self, track_clicks: bool) {
    self.track_clicks = Some(track_clicks);
  }

  pub fn with_track_clicks(mut self, track_clicks: bool) -> ModelsEmailMessage {
    self.track_clicks = Some(track_clicks);
    self
  }

  pub fn track_clicks(&self) -> Option<&bool> {
    self.track_clicks.as_ref()
  }

  pub fn reset_track_clicks(&mut self) {
    self.track_clicks = None;
  }

  pub fn set_track_opens(&mut self, track_opens: bool) {
    self.track_opens = Some(track_opens);
  }

  pub fn with_track_opens(mut self, track_opens: bool) -> ModelsEmailMessage {
    self.track_opens = Some(track_opens);
    self
  }

  pub fn track_opens(&self) -> Option<&bool> {
    self.track_opens.as_ref()
  }

  pub fn reset_track_opens(&mut self) {
    self.track_opens = None;
  }

}



