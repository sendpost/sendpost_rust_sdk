/* 
 * SendPost API
 *
 * SendPost API to send transactional emails reliably
 *
 * OpenAPI spec version: 1.0.0
 * Contact: hello@sendx.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ModelsIpStat {
  #[serde(rename = "clicked")]
  clicked: Option<i64>,
  #[serde(rename = "day")]
  day: Option<i64>,
  #[serde(rename = "delivered")]
  delivered: Option<i64>,
  #[serde(rename = "dropped")]
  dropped: Option<i64>,
  #[serde(rename = "hardBounced")]
  hard_bounced: Option<i64>,
  #[serde(rename = "month")]
  month: Option<i64>,
  #[serde(rename = "opened")]
  opened: Option<i64>,
  #[serde(rename = "processed")]
  processed: Option<i64>,
  #[serde(rename = "softBounced")]
  soft_bounced: Option<i64>,
  #[serde(rename = "spam")]
  spam: Option<i64>,
  #[serde(rename = "unsubscribed")]
  unsubscribed: Option<i64>,
  #[serde(rename = "year")]
  year: Option<i64>
}

impl ModelsIpStat {
  pub fn new() -> ModelsIpStat {
    ModelsIpStat {
      clicked: None,
      day: None,
      delivered: None,
      dropped: None,
      hard_bounced: None,
      month: None,
      opened: None,
      processed: None,
      soft_bounced: None,
      spam: None,
      unsubscribed: None,
      year: None
    }
  }

  pub fn set_clicked(&mut self, clicked: i64) {
    self.clicked = Some(clicked);
  }

  pub fn with_clicked(mut self, clicked: i64) -> ModelsIpStat {
    self.clicked = Some(clicked);
    self
  }

  pub fn clicked(&self) -> Option<&i64> {
    self.clicked.as_ref()
  }

  pub fn reset_clicked(&mut self) {
    self.clicked = None;
  }

  pub fn set_day(&mut self, day: i64) {
    self.day = Some(day);
  }

  pub fn with_day(mut self, day: i64) -> ModelsIpStat {
    self.day = Some(day);
    self
  }

  pub fn day(&self) -> Option<&i64> {
    self.day.as_ref()
  }

  pub fn reset_day(&mut self) {
    self.day = None;
  }

  pub fn set_delivered(&mut self, delivered: i64) {
    self.delivered = Some(delivered);
  }

  pub fn with_delivered(mut self, delivered: i64) -> ModelsIpStat {
    self.delivered = Some(delivered);
    self
  }

  pub fn delivered(&self) -> Option<&i64> {
    self.delivered.as_ref()
  }

  pub fn reset_delivered(&mut self) {
    self.delivered = None;
  }

  pub fn set_dropped(&mut self, dropped: i64) {
    self.dropped = Some(dropped);
  }

  pub fn with_dropped(mut self, dropped: i64) -> ModelsIpStat {
    self.dropped = Some(dropped);
    self
  }

  pub fn dropped(&self) -> Option<&i64> {
    self.dropped.as_ref()
  }

  pub fn reset_dropped(&mut self) {
    self.dropped = None;
  }

  pub fn set_hard_bounced(&mut self, hard_bounced: i64) {
    self.hard_bounced = Some(hard_bounced);
  }

  pub fn with_hard_bounced(mut self, hard_bounced: i64) -> ModelsIpStat {
    self.hard_bounced = Some(hard_bounced);
    self
  }

  pub fn hard_bounced(&self) -> Option<&i64> {
    self.hard_bounced.as_ref()
  }

  pub fn reset_hard_bounced(&mut self) {
    self.hard_bounced = None;
  }

  pub fn set_month(&mut self, month: i64) {
    self.month = Some(month);
  }

  pub fn with_month(mut self, month: i64) -> ModelsIpStat {
    self.month = Some(month);
    self
  }

  pub fn month(&self) -> Option<&i64> {
    self.month.as_ref()
  }

  pub fn reset_month(&mut self) {
    self.month = None;
  }

  pub fn set_opened(&mut self, opened: i64) {
    self.opened = Some(opened);
  }

  pub fn with_opened(mut self, opened: i64) -> ModelsIpStat {
    self.opened = Some(opened);
    self
  }

  pub fn opened(&self) -> Option<&i64> {
    self.opened.as_ref()
  }

  pub fn reset_opened(&mut self) {
    self.opened = None;
  }

  pub fn set_processed(&mut self, processed: i64) {
    self.processed = Some(processed);
  }

  pub fn with_processed(mut self, processed: i64) -> ModelsIpStat {
    self.processed = Some(processed);
    self
  }

  pub fn processed(&self) -> Option<&i64> {
    self.processed.as_ref()
  }

  pub fn reset_processed(&mut self) {
    self.processed = None;
  }

  pub fn set_soft_bounced(&mut self, soft_bounced: i64) {
    self.soft_bounced = Some(soft_bounced);
  }

  pub fn with_soft_bounced(mut self, soft_bounced: i64) -> ModelsIpStat {
    self.soft_bounced = Some(soft_bounced);
    self
  }

  pub fn soft_bounced(&self) -> Option<&i64> {
    self.soft_bounced.as_ref()
  }

  pub fn reset_soft_bounced(&mut self) {
    self.soft_bounced = None;
  }

  pub fn set_spam(&mut self, spam: i64) {
    self.spam = Some(spam);
  }

  pub fn with_spam(mut self, spam: i64) -> ModelsIpStat {
    self.spam = Some(spam);
    self
  }

  pub fn spam(&self) -> Option<&i64> {
    self.spam.as_ref()
  }

  pub fn reset_spam(&mut self) {
    self.spam = None;
  }

  pub fn set_unsubscribed(&mut self, unsubscribed: i64) {
    self.unsubscribed = Some(unsubscribed);
  }

  pub fn with_unsubscribed(mut self, unsubscribed: i64) -> ModelsIpStat {
    self.unsubscribed = Some(unsubscribed);
    self
  }

  pub fn unsubscribed(&self) -> Option<&i64> {
    self.unsubscribed.as_ref()
  }

  pub fn reset_unsubscribed(&mut self) {
    self.unsubscribed = None;
  }

  pub fn set_year(&mut self, year: i64) {
    self.year = Some(year);
  }

  pub fn with_year(mut self, year: i64) -> ModelsIpStat {
    self.year = Some(year);
    self
  }

  pub fn year(&self) -> Option<&i64> {
    self.year.as_ref()
  }

  pub fn reset_year(&mut self) {
    self.year = None;
  }

}



